# ROOT TEMPLATE: Spinnaker
# Schema is used internally to iterate the schema version of templates
# and configurations themselves.
schema: "1"
# Templates can be referenced, so it needs an ID.
id: spinnakerRoot
# A source is only needed when extending a parent template.
# source: WHATEVER-SOURCE
# While we could implicitly discover all of the variables used in a
# template, I prefer the route of explicitly defining them in a single
# location. Variables can be referenced across templates:
# "{TEMPLATE_ID}.var.{VAR_NAME}"
variables:
- name: bakeBaseLabel
  description: Optional field describing what the variable is for.
  type: int|float|string|list|object (default "string")
pipeline:
  template:
    id: spinnakerRoot
    # A source is only required if the template is decorating another
    # template. root templates do not have this value.
    # source: whatever source
    # Unsure if this should be inside of the pipeline, or not.
    variables: {}
configuration:
  # Default parameters offered by the template
  parameters: []
stages:
- id: bake
  name: Bake
  type: bake
  baseLabel: "{{ var.bakeBaseLabel }}"
  # ...
- id: deploy
  dependsOn: bake
  name: Deploy
  type: deploy
  clusters: "{{ module.deployClusters }}"
# Injecting some unnecessary stages for graph handling purposes...
# Would like to make checkPreconditions more... templated? Allow the
# child template to define how many to create? Maybe just make this a
# module?
# - id: checkPreconditions:
#   module: postDeployCheckPreconditions
- id: checkPreconditions0
  type: checkPreconditions
  dependsOn: deploy
  name: Check Preconditions (us-west-1)
  # ...
- id: checkPreconditions1
  type: checkPreconditions
  dependsOn: deploy
  name: Check Preconditions (us-east-1)
  # ...
- id: wait
  type: wait
  dependsOn: 
  - checkPreconditions0
  - checkPreconditions1
  duration: 60
- id: failoverDeploy
  dependsOn: wait
  type: deploy
  clusters: "{{ module.failoverDeployClusters }}"
  
# Additional documents are called "modules", which can be referenced by 
# the root template, each other, or replaced by child templates. At minimum,
# modules must have a document and associated "id" and "usage" fields.
# We might be able to add some conditional logic for importing different
# or multiple modules based on an expression. Like, "deployClusters" could
# have an AWS impl as well as a Titus impl. If the app only has "aws" 
# cloudprovider, it only imports that module; if both are defined, both
# get imported? Maybe it's better to make module imports from child 
# templates expicitly called.
---
id: deployClusters
usage: |
  Defines the clusters used within the deploy stage.
# The value of definition is what gets injected into the template. In
# this case, it's a list of cluster definitions.
definition:
# Do we want to consider allowing loops and conditionals within the
# templates? I hesitate to introduce any shitty loop constructs like 
# what Ansible does to remain declarative.
- account: "{{ var.account }}"
  healthCheckType: EC2
  cooldown: 10
  healthCheckGracePeriod: 600
  targetHealthyDeployPercentage: 100
  instanceType: m3.large
  # ...
